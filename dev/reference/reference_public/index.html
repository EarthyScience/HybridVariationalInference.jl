<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · HybridVariationalInference.jl</title><meta name="title" content="Public · HybridVariationalInference.jl"/><meta property="og:title" content="Public · HybridVariationalInference.jl"/><meta property="twitter:title" content="Public · HybridVariationalInference.jl"/><meta name="description" content="Documentation for HybridVariationalInference.jl."/><meta property="og:description" content="Documentation for HybridVariationalInference.jl."/><meta property="twitter:description" content="Documentation for HybridVariationalInference.jl."/><meta property="og:url" content="https://EarthyScience.github.io/HybridVariationalInference.jl/reference/reference_public/"/><meta property="twitter:url" content="https://EarthyScience.github.io/HybridVariationalInference.jl/reference/reference_public/"/><link rel="canonical" href="https://EarthyScience.github.io/HybridVariationalInference.jl/reference/reference_public/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HybridVariationalInference.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../problem/">Problem</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/basic_cpu/">Basic workflow</a></li><li><a class="tocitem" href="../../tutorials/inspect_results/">Inspect results</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../tutorials/lux_gpu/">.. use GPU</a></li><li><a class="tocitem" href="../../tutorials/blocks_corr/">.. model independent parameters</a></li><li><a class="tocitem" href="../../tutorials/corr_site_global/">.. model site-global corr</a></li></ul></li><li><span class="tocitem">Explanation</span></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Public</a></li><li><a class="tocitem" href="../reference_internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EarthyScience/HybridVariationalInference.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/main/docs/src/reference/reference_public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>In this reference, you will find a detailed overview of the package API, i.e. the docstrings.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.AbstractComponentArrayInterpreter" href="#HybridVariationalInference.AbstractComponentArrayInterpreter"><code>HybridVariationalInference.AbstractComponentArrayInterpreter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractComponentArrayInterpreter</code></pre><p>Interface for Type that implements</p><ul><li><code>as_ca(::AbstractArray, interpreter) -&gt; ComponentArray</code></li><li><code>ComponentArrays.getaxes(interpreter)</code></li><li><code>Base.length(interpreter) -&gt; Int</code></li></ul><p>When called on a vector, forwards to <code>as_ca</code>.</p><p>There is a default implementation for Base.length based on ComponentArrays.getaxes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.AbstractHybridProblem" href="#HybridVariationalInference.AbstractHybridProblem"><code>HybridVariationalInference.AbstractHybridProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type to dispatch constructing data and network structures for different cases of hybrid problem setups.</p><p>For a specific prob, provide functions that specify details</p><ul><li><code>get_hybridproblem_MLapplicator</code></li><li><code>get_hybridproblem_transforms</code></li><li><code>get_hybridproblem_PBmodel</code></li><li><code>get_hybridproblem_neg_logden_obs</code></li><li><code>get_hybridproblem_par_templates</code></li><li><code>get_hybridproblem_ϕunc</code></li><li><code>get_hybridproblem_train_dataloader</code> (may use <code>construct_dataloader_from_synthetic</code>)</li><li><code>get_hybridproblem_priors</code> </li><li><code>get_hybridproblem_n_covar</code> </li><li><code>get_hybridproblem_n_site_and_batch</code> </li></ul><p>optionally</p><ul><li><code>gen_hybridproblem_synthetic</code></li><li><code>get_hybridproblem_float_type</code> (defaults to <code>eltype(θM)</code>)</li><li><code>get_hybridproblem_cor_ends</code> (defaults to include all correlations:  <code>(P = [length(θP)], M = [length(θM)])</code>)</li><li><code>get_hybridproblem_pbmpar_covars</code> (defaults to empty tuple)</li></ul><p>The initial value of parameters to estimate is spread</p><ul><li><code>ϕg</code>: parameter of the MLapplicator: returned by <code>get_hybridproblem_MLapplicator</code></li><li><code>ζP</code>: mean of the PBmodel parameters: returned by <code>get_hybridproblem_par_templates</code></li><li><code>ϕunc</code>: additional parameters of the approximte posterior: returned by <code>get_hybridproblem_ϕunc</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.AbstractModelApplicator" href="#HybridVariationalInference.AbstractModelApplicator"><code>HybridVariationalInference.AbstractModelApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractModelApplicator(x, ϕ)</code></pre><p>Abstraction of applying a machine learning model at covariate matrix, <code>x</code>, using parameters, <code>ϕ</code>. It returns a matrix of predictions with the same number of rows as in <code>x</code>.    </p><p>Constructors for specifics are defined in extension packages. Each constructor takes a special type of machine learning model and returns  a tuple with two components:</p><ul><li>The applicator </li><li>a sample parameter vector (type  depends on the used ML-framework)</li></ul><p>Implemented are</p><ul><li><code>construct_SimpleChainsApplicator</code></li><li><code>construct_FluxApplicator</code></li><li><code>construct_LuxApplicator</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.AbstractPBMApplicator" href="#HybridVariationalInference.AbstractPBMApplicator"><code>HybridVariationalInference.AbstractPBMApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstraction of applying a process-based model with  global parameters, <code>θP</code>, site-specific parameters, <code>θMs</code> (sites in columns),  and site-specific model drivers, <code>xP</code> (sites in columns), It returns a matrix of predictions sites in columns.    </p><p>Specific implementations need to provide function <code>apply_model(app, θP, θMs, xP)</code>. where</p><ul><li><code>θsP</code> and <code>θsMs</code> are shaped according to the output of <code>generate_ζ</code>, i.e. <code>(n_site_pred x n_par x n_MC)</code>.</li><li>Results are of shape <code>(n_obs x n_site_pred x n_MC)</code>.</li></ul><p>They may also provide function <code>apply_model(app, θP, θMs, xP)</code> for a sample of parameters, i.e. where an additional dimension is added to both <code>θP</code> and <code>θMs</code>. However, there is a default implementation that mapreduces across these dimensions.</p><p>Provided are implementations</p><ul><li><code>PBMSiteApplicator</code>: based on a function that computes predictions per site</li><li><code>PBMPopulationApplicator</code>: based on a function that computes predictions for entire population</li><li><code>NullPBMApplicator</code>: returning its input <code>θMs</code> for testing</li><li><code>DirectPBMApplicator</code>: based on a function that takes the same arguments as <code>apply_model</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/PBMApplicator.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.ComponentArrayInterpreter" href="#HybridVariationalInference.ComponentArrayInterpreter"><code>HybridVariationalInference.ComponentArrayInterpreter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Non-Concrete version of <code>AbstractComponentArrayInterpreter</code> that avoids storing additional type parameters.</p><p>Does not trigger specialization for Interpreters of different axes, but does not allow compiler-inferred <code>length</code> to construct StaticArrays.</p><p>Use <code>get_concrete(cai::ComponentArrayInterpreter)</code> to pass a concrete version to  performance-critical functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.ComponentArrayInterpreter-Tuple{}" href="#HybridVariationalInference.ComponentArrayInterpreter-Tuple{}"><code>HybridVariationalInference.ComponentArrayInterpreter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ComponentArrayInterpreter(; kwargs...)
ComponentArrayInterpreter(::AbstractComponentArray)

ComponentArrayInterpreter(::AbstractComponentArray, n_dims::NTuple{N,&lt;:Integer})
ComponentArrayInterpreter(n_dims::NTuple{N,&lt;:Integer}, ::AbstractComponentArray)
ComponentArrayInterpreter(n_dims::NTuple{N,&lt;:Integer}, ::AbstractComponentArray, m_dims::NTuple{M,&lt;:Integer})</code></pre><p>Construct a <code>ComponentArrayInterpreter &lt;: AbstractComponentArrayInterpreter</code> with components being vectors of given length or given model of a <code>AbstractComponentArray</code>.</p><p>The other constructors allow constructing arrays with additional dimensions.</p><p>&#39;&#39;&#39;julia     interpreter = ComponentArrayInterpreter(; P=2, M=(2,3), Unc=5)     v = 1.0:length(interpreter)     interpreter(v).M == 2 .+ [1 3 5; 2 4 6]     vm = stack((v,v .* 10, v .* 100))</p><pre><code class="nohighlight hljs">intm = ComponentArrayInterpreter(interpreter(v), (3,))
intm(vm)[:Unc, 2]</code></pre><p>&#39;&#39;&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L108-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.DirectPBMApplicator" href="#HybridVariationalInference.DirectPBMApplicator"><code>HybridVariationalInference.DirectPBMApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectPBMApplicator()</code></pre><p>Process-based-Model applicator that invokes directly given  function <code>f(θP::AbstractVector, θMs::AbstractMatrix, xP)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/PBMApplicator.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.Exp" href="#HybridVariationalInference.Exp"><code>HybridVariationalInference.Exp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Exp()</code></pre><p>A bijector that applies broadcasted exponential function, i.e. <code>exp.(x)</code>. It is equivalent to <code>elementwise(exp)</code> but works better with automatic differentiation on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/bijectors_utils.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.HybridProblem" href="#HybridVariationalInference.HybridProblem"><code>HybridVariationalInference.HybridProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implements <a href="#HybridVariationalInference.AbstractHybridProblem"><code>AbstractHybridProblem</code></a> by gathering all the parts into  one struct.</p><p>Fields:</p><ul><li><code>θP::ComponentVector</code>, <code>θM::ComponentVector</code>: parameter templates</li><li><code>g::AbstractModelApplicator</code>, <code>ϕg::AbstractVector</code>: ML model and its parameters </li><li><code>ϕunc::ComponentVector</code>: parameters for the Covariance matrix of the approximate posterior</li><li><code>f_batch</code>: Process-based model predicing for <code>n_batch</code> sites</li><li><code>f_allsites</code>: Process-based model predicing for <code>n_site</code> sites</li><li><code>priors</code>: AbstractDict: Prior distributions for all PBM parameters on constrained scale</li><li><code>py</code>: Likelihood function</li><li><code>transM::Stacked</code>, <code>transP::Stacked</code>: bijectors transforming from unconstrained to  constrained scale for site-specific and global parameters respectively.</li><li><code>train_dataloader::MLUtils.DataLoader</code>: providingn Tuple of matrices  <code>(xM, xP, y_o, y_unc, i_sites)</code>: covariates, model drivers, observations,  observation uncertainties and index of provided sites.</li><li><code>n_covar::Int</code>, <code>n_site::Int</code>, <code>n_batch::Int</code>: number covariates, number of sites, and number of sites within one batch</li><li><code>cor_ends::NamedTuple</code>: block structure in correlations,  defaults to  <code>(P = [length(θP)], M = [length(θM)])</code></li><li><code>pbm_covars::NTuple{N,Symbol}</code>: names of global parameters used as covariates  in the ML model, defaults to <code>()</code>, i.e. no covariates fed into the ML model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/HybridProblem.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.HybridProblem-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.HybridProblem-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.HybridProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HybridProblem(prob::AbstractHybridProblem; scenario = ()</code></pre><p>Gather all information from another <code>AbstractHybridProblem</code> with possible updating of some of the entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/HybridProblem.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.MagnitudeModelApplicator" href="#HybridVariationalInference.MagnitudeModelApplicator"><code>HybridVariationalInference.MagnitudeModelApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MagnitudeModelApplicator(app, y0)</code></pre><p>Wrapper around AbstractModelApplicator that multiplies the prediction of the wrapped <code>app</code> by scalar <code>y0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.NormalScalingModelApplicator" href="#HybridVariationalInference.NormalScalingModelApplicator"><code>HybridVariationalInference.NormalScalingModelApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NormalScalingModelApplicator(app, μ, σ)
NormalScalingModelApplicator(app, priors, transM)</code></pre><p>Wrapper around AbstractModelApplicator that transforms each output  (assumed in [0..1], such as output of logistic activation function) to a quantile of a Normal distribution. </p><p>Length of μ, σ must correspond to the number of outputs of the wrapped ModelApplicator.</p><p>This helps to keep raw ML-predictions (in confidence bounds) and weights in a  similar magnitude. Compared to specifying bounds, this allows for the possibility  (although harder to converge) far beyond the confidence bounds.</p><p>The second constructor fits a normal distribution of the inverse-transformed 5% and 95% quantiles of prior distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L112-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.NormalScalingModelApplicator-Tuple{AbstractModelApplicator, Any, Any, Type}" href="#HybridVariationalInference.NormalScalingModelApplicator-Tuple{AbstractModelApplicator, Any, Any, Type}"><code>HybridVariationalInference.NormalScalingModelApplicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NormalScalingModelApplicator(app, lowers, uppers, FT::Type; repeat_inner::Integer = 1)</code></pre><p>Fit a Normal distribution to number iterators <code>lower</code> and <code>upper</code> and transform  results of the wrapped <code>app</code> <code>AbstractModelApplicator</code>. If <code>repeat_inner</code> is given, each fitted distribution is repeated as many times to support independent multivariate normal distribution.</p><p><code>FT</code> is the specific FloatType to use to construct Distributions,  It usually corresponds to the type used in other ML-parts of the model, e.g. <code>Float32</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.NullModelApplicator" href="#HybridVariationalInference.NullModelApplicator"><code>HybridVariationalInference.NullModelApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullModelApplicator()</code></pre><p>Model applicator that returns its inputs. Used for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.NullPBMApplicator" href="#HybridVariationalInference.NullPBMApplicator"><code>HybridVariationalInference.NullPBMApplicator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullPBMApplicator()</code></pre><p>Process-Base-Model applicator that returns its θMs inputs. Used for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/PBMApplicator.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.PBMPopulationApplicator-Tuple{Any, Any}" href="#HybridVariationalInference.PBMPopulationApplicator-Tuple{Any, Any}"><code>HybridVariationalInference.PBMPopulationApplicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PBMPopulationApplicator(fθpop, n_batch; θP, θM, θFix, xPvec)</code></pre><p>Construct AbstractPBMApplicator from process-based model <code>fθ</code> that computes predictions across sites for a population of size <code>n_batch</code>. The applicator combines enclosed <code>θFix</code>, with provided <code>θMs</code> and <code>θP</code> to a <code>ComponentMatrix</code> with parameters with one row for each site, that can be column-indexed by Symbols.</p><p><strong>Arguments</strong></p><ul><li><code>fθpop</code>: process model, process model <code>f(θc, xPc)</code>, which is agnostic of the partitioning  of parameters into fixed, global, and individual.<ul><li><code>θc</code>: parameters: <code>ComponentMatrix</code> (n<em>site x n</em>par) with each row a parameter vector</li><li><code>xPc</code>: observations: <code>ComponentMatrix</code> (n<em>obs x n</em>site) with each column </li></ul>observationsfor one site</li><li><code>n_batch</code>: number of indiduals, i.e. rows in <code>θMs</code></li><li><code>θP</code>: <code>ComponentVector</code> template of global process model parameters</li><li><code>θM</code>: <code>ComponentVector</code> template of individual process model parameters</li><li><code>θFix</code>: <code>ComponentVector</code> of actual fixed process model parameters</li><li><code>xPvec</code>: <code>ComponentVector</code> template of model drivers for a single site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/PBMApplicator.jl#L191-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.PBMSiteApplicator-Tuple{Any}" href="#HybridVariationalInference.PBMSiteApplicator-Tuple{Any}"><code>HybridVariationalInference.PBMSiteApplicator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PBMSiteApplicator(fθ, n_batch; θP, θM, θFix, xPvec)</code></pre><p>Construct AbstractPBMApplicator from process-based model <code>fθ</code> that computes predictions for a single site. The Applicator combines enclosed <code>θFix</code>, with provided <code>θMs</code> and <code>θP</code> and constructs a <code>ComponentVector</code> that can be indexed by  symbolic parameter names, corresponding to the templates provided during construction of the applicator.</p><p><strong>Arguments</strong></p><ul><li><code>fθ</code>: process model, process model <code>fθ(θc, xP)</code>, which is agnostic of the partitioning</li></ul><p>of parameters.</p><ul><li><code>θP</code>: <code>ComponentVector</code> template of global process model parameters</li><li><code>θM</code>: <code>ComponentVector</code> template of individual process model parameters</li><li><code>θFix</code>: <code>ComponentVector</code> of actual fixed process model parameters</li><li><code>xPvec</code>:<code>ComponentVector</code> template of model drivers for a single site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/PBMApplicator.jl#L116-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.StackedArray" href="#HybridVariationalInference.StackedArray"><code>HybridVariationalInference.StackedArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StackedArray(stacked, nrow)</code></pre><p>A Bijectors.Transform that applies stacked to each column of an n-row matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/bijectors_utils.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.StaticComponentArrayInterpreter" href="#HybridVariationalInference.StaticComponentArrayInterpreter"><code>HybridVariationalInference.StaticComponentArrayInterpreter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Concrete version of <code>AbstractComponentArrayInterpreter</code> that stores an axis in its type signature.</p><p>Allows compiler-inferred <code>length</code> to construct StaticArrays, but requires specialization on dispatch when provided as an argument to a function.</p><p>Use <code>get_concrete(cai::ComponentArrayInterpreter)</code> to pass a concrete version to  performance-critical functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.apply_preserve_axes-Tuple{Any, ComponentArrays.ComponentArray}" href="#HybridVariationalInference.apply_preserve_axes-Tuple{Any, ComponentArrays.ComponentArray}"><code>HybridVariationalInference.apply_preserve_axes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_preserve_axes(f, ca::ComponentArray)</code></pre><p>Apply callable <code>f(x)</code> to the data inside <code>ca</code>, assume that the result has the same shape, and return a new <code>ComponentArray</code> with the same axes as in <code>ca</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/util_ca.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.callback_loss" href="#HybridVariationalInference.callback_loss"><code>HybridVariationalInference.callback_loss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>create a function (state, l) -&gt; false that prints iter and loss each moditer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/util_opt.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.compute_correlated_covars-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T}}} where T" href="#HybridVariationalInference.compute_correlated_covars-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T}}} where T"><code>HybridVariationalInference.compute_correlated_covars</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create <code>n_covar</code> correlated covariates  from uncorrelated row-wise vector <code>x_pc</code>, with correlations <code>rhos</code> to the linear combinations of <code>x_pc</code>.</p><p>By default correlations, <code>rhos = (1.0),0.88,0.78,0.69,0.61 ...</code>,  decrease exponentially as <code>e^{-i/rhodec}</code>, with <code>rhodec = 8</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/gencovar.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.construct_3layer_MLApplicator" href="#HybridVariationalInference.construct_3layer_MLApplicator"><code>HybridVariationalInference.construct_3layer_MLApplicator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_3layer_MLApplicator(
    rng::AbstractRNG, prob::HVI.AbstractHybridProblem, &lt;ml_engine&gt;;
    scenario::Val{scen}) where scen</code></pre><p>Construct a machine learning model for given Proglem and machine learning engine. Implemented for machine learning extensions, such as Flux or SimpleChains. <code>ml_engine</code> usually is of type <code>Val{Symbol}</code>, e.g. Val(:Flux). See <code>select_ml_engine</code>.       </p><p>Scenario is a value-type of <code>NTuple{_,Symbol}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.construct_ChainsApplicator" href="#HybridVariationalInference.construct_ChainsApplicator"><code>HybridVariationalInference.construct_ChainsApplicator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_ChainsApplicator([rng::AbstractRNG,] chain, float_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L48-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.construct_dataloader_from_synthetic-Tuple{Random.AbstractRNG, AbstractHybridProblem}" href="#HybridVariationalInference.construct_dataloader_from_synthetic-Tuple{Random.AbstractRNG, AbstractHybridProblem}"><code>HybridVariationalInference.construct_dataloader_from_synthetic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_dataloader_from_synthetic(rng::AbstractRNG, prob::AbstractHybridProblem;
    scenario = (), n_batch)</code></pre><p>Construct a dataloader based on <code>gen_hybridproblem_synthetic</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L170-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.construct_partric-Tuple{AbstractModelApplicator, Any, Any}" href="#HybridVariationalInference.construct_partric-Tuple{AbstractModelApplicator, Any, Any}"><code>HybridVariationalInference.construct_partric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct a parametric type-stable model applicator, given covariates, <code>x</code>, and parameters, <code>ϕ</code>.</p><p>The default returns the current model applicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.cpu_ca-Tuple{ComponentArrays.ComponentArray}" href="#HybridVariationalInference.cpu_ca-Tuple{ComponentArrays.ComponentArray}"><code>HybridVariationalInference.cpu_ca</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cpu_ca(ca::CA.ComponentArray)</code></pre><p>Move ComponentArray form gpu to cpu.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/util_ca.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.extend_stacked_nrow-Tuple{Bijectors.Stacked, Integer}" href="#HybridVariationalInference.extend_stacked_nrow-Tuple{Bijectors.Stacked, Integer}"><code>HybridVariationalInference.extend_stacked_nrow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extend_stacked_nrow(b::Stacked, nrow::Integer)</code></pre><p>Create a Stacked bijectors that transforms nrow times the elements of the original Stacked bijector.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">X = reduce(hcat, ([x + y for x in 0:4 ] for y in 0:10:30))
b1 = CP.Exp()
b2 = identity
b = Stacked((b1,b2), (1:1,2:4))
bs = extend_stacked_nrow(b, size(X,1))
Xt = reshape(bs(vec(X)), size(X))
@test Xt[:,1] == b1(X[:,1])
@test Xt[:,2:4] == b2(X[:,2:4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/bijectors_utils.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.flatten1-Tuple{ComponentArrays.ComponentVector}" href="#HybridVariationalInference.flatten1-Tuple{ComponentArrays.ComponentVector}"><code>HybridVariationalInference.flatten1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten1(cv::CA.ComponentVector)</code></pre><p>Removes the highest level of keys. Keeps the reference to the underlying data, but changes the axis. If first-level vector has no sub-names, an error (Aguement Error tuple must be non-empty) is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L246-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.gdev_hybridproblem_dataloader-Tuple{MLUtils.DataLoader}" href="#HybridVariationalInference.gdev_hybridproblem_dataloader-Tuple{MLUtils.DataLoader}"><code>HybridVariationalInference.gdev_hybridproblem_dataloader</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gdev_hybridproblem_dataloader(dataloader::MLUtils.DataLoader; gdev_M, gdev_P,
    batchsize = dataloader.batchsize,
    partial = dataloader.partial
    )</code></pre><p>Put relevant parts of the DataLoader to gpu, depending on scenario.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L192-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.gen_cov_pred-Tuple{Random.AbstractRNG, DataType, Any, Any, Any, Integer}" href="#HybridVariationalInference.gen_cov_pred-Tuple{Random.AbstractRNG, DataType, Any, Any, Any, Integer}"><code>HybridVariationalInference.gen_cov_pred</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Generate correlated covariates and synthetic true parameters that are a linear combination of the uncorrelated underlying principal  factors and their binary combinations.</p><p>In addition provide a SimpleChains model of adequate complexity to fit this relationship θMs<em>true = f(x</em>o)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/gencovar.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.gen_hybridproblem_synthetic" href="#HybridVariationalInference.gen_hybridproblem_synthetic"><code>HybridVariationalInference.gen_hybridproblem_synthetic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gen_hybridproblem_synthetic([rng,] ::AbstractHybridProblem; scenario)</code></pre><p>Setup synthetic data, a NamedTuple of</p><ul><li>xM: matrix of covariates, with one column per site</li><li>θP_true: vector global process-model parameters</li><li>θMs_true: matrix of site-varying process-model parameters, with </li><li>xP: Vector of process-model drivers, with an entry per site</li><li>y_true: matrix of site-specific observations with one column per site</li><li>y_o: observations with added noise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L136-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_ca_ends-Tuple{ComponentArrays.ComponentVector}" href="#HybridVariationalInference.get_ca_ends-Tuple{ComponentArrays.ComponentVector}"><code>HybridVariationalInference.get_ca_ends</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ca_ends(vc::ComponentVector)</code></pre><p>Return a Vector with ending positions of components in vc.  Useful for providing information on correlactions among subranges in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/cholesky.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_ca_starts-Tuple{ComponentArrays.ComponentVector}" href="#HybridVariationalInference.get_ca_starts-Tuple{ComponentArrays.ComponentVector}"><code>HybridVariationalInference.get_ca_starts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ca_starts(vc::ComponentVector)</code></pre><p>Return a tuple with starting positions of components in vc.  Useful for providing information on correlactions among subranges in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/cholesky.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_cor_count-Tuple{AbstractVector}" href="#HybridVariationalInference.get_cor_count-Tuple{AbstractVector}"><code>HybridVariationalInference.get_cor_count</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cor_count(cor_ends::AbstractVector)
get_cor_count(n_par::Integer)</code></pre><p>Return number of correlation coefficients for a correlation matrix of size <code>(npar x npar)</code> With blocks starting a positions given with tuple <code>cor_ends</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/cholesky.jl#L218-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_gdev_MP-Union{Tuple{Val{scen}}, Tuple{scen}} where scen" href="#HybridVariationalInference.get_gdev_MP-Union{Tuple{Val{scen}}, Tuple{scen}} where scen"><code>HybridVariationalInference.get_gdev_MP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_gcdev(scenario::Val{scen}) where scen</code></pre><p>Configure the function that puts data and computations to gpu device  for given <code>scenario</code>. Checking for <code>:use_gpu</code> and <code>:f_on_gpu</code> in <code>scenario</code>. Returns a <code>NamedTuple</code> <code>(;gdev_M, gdev_P)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_MLapplicator" href="#HybridVariationalInference.get_hybridproblem_MLapplicator"><code>HybridVariationalInference.get_hybridproblem_MLapplicator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_MLapplicator([rng::AbstractRNG,] ::AbstractHybridProblem; scenario=())</code></pre><p>Construct the machine learning model fro given problem prob and ML-Framework and  scenario.</p><p>returns a Tuple of</p><ul><li>AbstractModelApplicator</li><li>initial parameter vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_PBmodel" href="#HybridVariationalInference.get_hybridproblem_PBmodel"><code>HybridVariationalInference.get_hybridproblem_PBmodel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_PBmodel(::AbstractHybridProblem; scenario::NTuple=())</code></pre><p>Construct the process-based model function  <code>f(θP::AbstractVector, θMs::AbstractMatrix, x) -&gt; (AbstractVector, AbstractMatrix)</code> with</p><ul><li>θP: calibrated parameters that are constant across site</li><li>θMs: calibrated parameters that vary across sites, with a  column for each site</li><li>x: drivers, indexed by site</li></ul><p>returns a tuple of predictions with components</p><ul><li>first, those that are constant across sites</li><li>second, those that vary across sites, with a column for each site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L48-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_cor_ends-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.get_hybridproblem_cor_ends-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.get_hybridproblem_cor_ends</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_cor_ends(prob::AbstractHybridProblem; scenario)</code></pre><p>Specify blocks in correlation matrices among parameters. Returns a NamedTuple.</p><ul><li><code>P</code>: correlations among global parameters</li><li><code>M</code>: correlations among ML-predicted parameters</li></ul><p>Subsets ofparameters that are correlated with other but not correlated with parameters of other subranges are specified by indicating the starting position of each subrange. E.g. if within global parameter vector <code>(p1, p2, p3)</code>, <code>p1</code> and <code>p2</code> are correlated,  but parameter <code>p3</code> is not correlated with them, then the first subrange starts at position 1 and the second subrange starts at position 3. If there is only single block of all ML-predicted parameters being correlated  with each other then this block starts at position 1: <code>(P=(1,3), M=(1,))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L257-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_float_type-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.get_hybridproblem_float_type-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.get_hybridproblem_float_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_float_type(::AbstractHybridProblem; scenario)</code></pre><p>Determine the FloatType for given Case and scenario, defaults to Float32</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_n_covar-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.get_hybridproblem_n_covar-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.get_hybridproblem_n_covar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_n_covar(::AbstractHybridProblem; scenario)</code></pre><p>Provide the number of covariates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_n_site_and_batch" href="#HybridVariationalInference.get_hybridproblem_n_site_and_batch"><code>HybridVariationalInference.get_hybridproblem_n_site_and_batch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_n_site_and_batch(::AbstractHybridProblem; scenario)</code></pre><p>Provide the number of sites. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_neg_logden_obs" href="#HybridVariationalInference.get_hybridproblem_neg_logden_obs"><code>HybridVariationalInference.get_hybridproblem_neg_logden_obs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_neg_logden_obs(::AbstractHybridProblem; scenario)</code></pre><p>Provide a <code>function(y_obs, ypred) -&gt; Real</code> that computes the negative logdensity of the observations, given the predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_par_templates" href="#HybridVariationalInference.get_hybridproblem_par_templates"><code>HybridVariationalInference.get_hybridproblem_par_templates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_par_templates(::AbstractHybridProblem; scenario)</code></pre><p>Provide tuple of templates of ComponentVectors <code>θP</code> and <code>θM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_priors-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.get_hybridproblem_priors-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.get_hybridproblem_priors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_priors(::AbstractHybridProblem; scenario)</code></pre><p>Return a dictionary of marginal prior distributions for components in <code>θP</code> and <code>θM</code>. Defaults for each component <code>θ</code> to <code>Normal(θ, max(θ, 1.0))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_train_dataloader" href="#HybridVariationalInference.get_hybridproblem_train_dataloader"><code>HybridVariationalInference.get_hybridproblem_train_dataloader</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_train_dataloader(::AbstractHybridProblem; scenario, n_batch)</code></pre><p>Return a DataLoader that provides a tuple of</p><ul><li><code>xM</code>: matrix of covariates, with one column per site</li><li><code>xP</code>: Iterator of process-model drivers, with one element per site</li><li><code>y_o</code>: matrix of observations with added noise, with one column per site</li><li><code>y_unc</code>: matrix <code>sizeof(y_o)</code> of uncertainty information </li><li><code>i_sites</code>: Vector of indices of sites in the minibatch</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L158-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_transforms" href="#HybridVariationalInference.get_hybridproblem_transforms"><code>HybridVariationalInference.get_hybridproblem_transforms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_transforms(::AbstractHybridProblem; scenario)</code></pre><p>Return a NamedTupe of</p><ul><li><code>transP</code>: Bijectors.Transform for the global PBM parameters, θP</li><li><code>transM</code>: Bijectors.Transform for the single-site PBM parameters, θM</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_hybridproblem_ϕunc-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.get_hybridproblem_ϕunc-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.get_hybridproblem_ϕunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_hybridproblem_ϕunc(::AbstractHybridProblem; scenario)</code></pre><p>Provide a ComponentArray of the initial additional parameters of the approximate posterior. Defaults to zero correlation and log_σ2 of 1e-10.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/AbstractHybridProblem.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_loss_gf" href="#HybridVariationalInference.get_loss_gf"><code>HybridVariationalInference.get_loss_gf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create a loss function for given</p><ul><li>g(x, ϕ): machine learning model </li><li>transM: transforamtion of parameters at unconstrained space</li><li>f(θMs, θP): mechanistic model </li><li>intϕ: interpreter attaching axis with components ϕg and ϕP</li><li>intP: interpreter attaching axis to ζP = ϕP with components used by f</li><li>kwargs: additional keyword arguments passed to gf, such as gdev or pbm_covars</li></ul><p>The loss function <code>loss_gf(ϕ, xM, xP, y_o, y_unc, i_sites)</code> takes   </p><ul><li>parameter vector ϕ</li><li>xM: matrix of covariate, sites in the batch are in columns</li><li>xP: iteration of drivers for each site</li><li>y_o: matrix of observations, sites in columns</li><li>y_unc: vector of uncertainty information for each observation</li><li>i_sites: index of sites in the batch</li></ul><p>and returns a NamedTuple of </p><ul><li><code>nLjoint</code>: the negative-log of the joint parameter probability (Likelihood * prior)</li><li><code>y_pred</code>: predicted values</li><li><code>θMs</code>, <code>θP</code>: PBM-parameters </li><li><code>nLy</code>: negative log-Likelihood of y_pred</li><li><code>neg_log_prior</code>: negative log-prior of <code>θMs</code> and <code>θP</code></li><li><code>neg_log_prior</code>: negative log-prior of <code>θMs</code> and <code>θP</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/gf.jl#L135-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_positions-Tuple{AbstractComponentArrayInterpreter}" href="#HybridVariationalInference.get_positions-Tuple{AbstractComponentArrayInterpreter}"><code>HybridVariationalInference.get_positions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_positions(cai::AbstractComponentArrayInterpreter)</code></pre><p>Create a NamedTuple of integer indices for each component. Assumes that interpreter results in a one-dimensional array, i.e. in a ComponentVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.get_quantile_transformed-Tuple{AbstractVector{&lt;:Distributions.Distribution}, Any}" href="#HybridVariationalInference.get_quantile_transformed-Tuple{AbstractVector{&lt;:Distributions.Distribution}, Any}"><code>HybridVariationalInference.get_quantile_transformed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the inverse-transformation of lower and upper quantiles of a Vector of Distributions.</p><p>This can be used to get proper confidence intervals at unconstrained (log) ζ-scale for priors on normal θ-scale for constructing a NormalScalingModelApplicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/HybridProblem.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.gf-Tuple{AbstractHybridProblem}" href="#HybridVariationalInference.gf-Tuple{AbstractHybridProblem}"><code>HybridVariationalInference.gf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>composition f ∘ transM ∘ g: mechanistic model after machine learning parameter prediction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/gf.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.init_hybrid_params-Union{Tuple{FT}, Tuple{AbstractVector{FT}, AbstractVector{FT}, NamedTuple, AbstractVector{FT}, HybridProblemInterpreters}} where FT" href="#HybridVariationalInference.init_hybrid_params-Union{Tuple{FT}, Tuple{AbstractVector{FT}, AbstractVector{FT}, NamedTuple, AbstractVector{FT}, HybridProblemInterpreters}} where FT"><code>HybridVariationalInference.init_hybrid_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_hybrid_params(θP, θM, ϕg, n_batch; transP=asℝ, transM=asℝ)</code></pre><p>Setup ComponentVector of parameters to optimize, and associated tools. Returns a NamedTuple of</p><ul><li>ϕ: A ComponentVector of parameters to optimize</li><li>transPMs<em>batch, interpreters: Transformations and interpreters as  required by `neg</em>elbo_gtf`.</li><li>get<em>transPMs: a function returning transformations `(n</em>site) -&gt; (;P,Ms)`</li><li>get<em>ca</em>int<em>PMs: a function returning ComponentArrayInterpreter for PMs vector  with PMs shaped as a matrix of `n</em>site<code>columns of</code>θM`</li></ul><p><strong>Arguments</strong></p><ul><li><code>θP</code>, <code>θM</code>: Template ComponentVectors of global parameters and ML-predicted parameters</li><li><code>cor_ends</code>: NamedTuple with entries, <code>P</code>, and <code>M</code>, respectively with   integer vectors of ending columns of parameters blocks</li><li><code>ϕg</code>: vector of parameters to optimize, as returned by <code>get_hybridproblem_MLapplicator</code></li><li><code>n_batch</code>: the number of sites to predicted in each mini-batch</li><li><code>transP</code>, <code>transM</code>: the Bijector.Transformations for the global and site-dependent    parameters, e.g. <code>Stacked(elementwise(identity), elementwise(exp), elementwise(exp))</code>.   Its the transformation froing from unconstrained to constrained space: θ = Tinv(ζ),   because this direction is used much more often.</li><li><code>ϕunc0</code> initial uncertainty parameters, ComponentVector with format of <code>init_hybrid_ϕunc.</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/init_hybrid_params.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.init_hybrid_ϕunc-Union{Tuple{NamedTuple}, Tuple{FT}, Tuple{NamedTuple, FT}, Tuple{NamedTuple, FT, AbstractVector{FT}}} where FT" href="#HybridVariationalInference.init_hybrid_ϕunc-Union{Tuple{NamedTuple}, Tuple{FT}, Tuple{NamedTuple, FT}, Tuple{NamedTuple, FT, AbstractVector{FT}}} where FT"><code>HybridVariationalInference.init_hybrid_ϕunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_hybrid_ϕunc(cor_ends, ρ0=0f0; logσ2_ζP, coef_logσ2_ζMs, ρsP, ρsM)</code></pre><p>Initialize vector of additional parameter of the approximate posterior.</p><p>Arguments:</p><ul><li><code>cor_ends</code>: NamedTuple with entries, <code>P</code>, and <code>M</code>, respectively with   integer vectors of ending columns of parameters blocks</li><li><code>ρ0</code>: default entry for ρsP and ρsM, defaults = 0f0.</li><li><code>coef_logσ2_logM</code>: default column for <code>coef_logσ2_ζMs</code>, defaults to <code>[-10.0, 0.0]</code></li></ul><p>Returns a <code>ComponentVector</code> of </p><ul><li><code>logσ2_ζP</code>: vector of log-variances of ζP (on log scale). defaults to -10</li><li><code>coef_logσ2_ζMs</code>: offset and slope for the log-variances of ζM scaling with   its value given by columns for each parameter in ζM, defaults to <code>[-10, 0]</code></li><li><code>ρsP</code> and <code>ρsM</code>: parameterization of the upper triangular cholesky factor  of the correlation matrices of ζP and ζM, default to all entries <code>ρ0</code>, which defaults to zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/init_hybrid_params.jl#L74-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.neg_elbo_gtf-Tuple" href="#HybridVariationalInference.neg_elbo_gtf-Tuple"><code>HybridVariationalInference.neg_elbo_gtf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Cost function (ELBO) for hybrid model with batched sites.</p><p>It generates n_MC samples for each site, and uses these to compute the expected value of the likelihood of observations.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: random number generator (ignored on CUDA, if ϕ is a AbstractGPUArray)</li><li><code>ϕ</code>: flat vector of parameters interpreted by interpreters.μP<em>ϕg</em>unc and interpreters.PMs</li><li><code>g</code>: machine learning model</li><li><code>transPMs</code>: Transformations as generated by get<em>transPMs returned from init</em>hybrid_params</li><li><code>f</code>: mechanistic model</li><li><code>py</code>: negative log-likelihood of observations given predictions:  <code>function(y_ob, y_pred, y_unc)</code></li><li><code>xM</code>, <code>xP</code>, <code>y_ob</code>, <code>y_unc</code>, <code>i_sites</code>: information of the sites in the current minibatch<ul><li><code>xM</code>: matrix of covariates (n<em>cov x n</em>site_batch)</li><li><code>xP</code>: model drivers, iterable of (n<em>site</em>batch)</li><li><code>y_ob</code>: matrix of observations (n<em>obs x n</em>site_batch)</li><li><code>y_unc</code>: observation uncertainty provided to py (same size as y_ob)</li><li><code>i_sites</code>: indices of sites for current minibatch</li></ul></li><li><code>interpreters</code>: NamedTuple as generated by <code>gen_hybridproblem_synthetic</code> with entries:<ul><li><code>μP_ϕg_unc</code>: extract components of parameter of <ol><li>means of global PBM, 2) ML-weights, and 3) additional parameters of approximation q</li></ol></li><li><code>PMs</code>: assign components to PBM parameters 1 global, 2 matrix of n_site column  vectors</li><li><code>int_unc</code> (can be omitted, if <code>μP_ϕg_unc(ϕ).unc</code> is already a ComponentVector)</li></ul></li><li><code>n_MC</code>: number of MonteCarlo samples from the distribution of parameters to simulate using the mechanistic model f.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/elbo.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.neg_logden_indep_normal-Union{Tuple{ET}, Tuple{AbstractArray, AbstractArray, AbstractArray{ET}}} where ET" href="#HybridVariationalInference.neg_logden_indep_normal-Union{Tuple{ET}, Tuple{AbstractArray, AbstractArray, AbstractArray{ET}}} where ET"><code>HybridVariationalInference.neg_logden_indep_normal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neg_logden_indep_normal(obs, μ, logσ2s; σfac=1.0)</code></pre><p>Compute the negative Log-density of <code>θM</code> for multiple independent normal distributions, given estimated means <code>μ</code> and estimated log of variance parameters <code>logσ2s</code>.</p><p>All the arguments should be vectors of the same length. If <code>obs</code>,  <code>μ</code> are given as a matrix of several column-vectors, their summed Likelihood is computed, assuming each column having the same <code>logσ2s</code>.</p><p>Keyword argument <code>σfac</code> can be increased to put more weight on achieving a low uncertainty estimate and means closer to the observations to help an initial fit. The obtained parameters then can be used as starting values for a the proper fit with <code>σfac=1.0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/logden_normal.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.predict_hvi-Tuple{Any, AbstractHybridProblem}" href="#HybridVariationalInference.predict_hvi-Tuple{Any, AbstractHybridProblem}"><code>HybridVariationalInference.predict_hvi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_hvi([rng], predict_hvi(rng, prob::AbstractHybridProblem)</code></pre><p>Prediction function for hybrid variational inference parameter model. </p><p><strong>Arguments</strong></p><ul><li>The problem for which to predict</li><li>xM: covariates for the machine-learning model (ML): Matrix (n<em>θM x n</em>site_pred).</li><li>xP: model drivers for process based model (PBM): Matrix with (n<em>site</em>pred) rows. If provided a ComponentArray with a Tuple-Axis in rows, the PBM model can access parts of it, e.g. <code>xP[:S1,...]</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>scenario</code></li><li><code>n_sample_pred</code></li></ul><p>Returns an NamedTuple <code>(; y, θsP, θsMs, entropy_ζ)</code> with entries</p><ul><li><code>y</code>: Array <code>(n_obs, n_site, n_sample_pred)</code> of model predictions.</li><li><code>θsP</code>: ComponentArray <code>(n_θP, n_sample_pred)</code> of PBM model parameters that are kept constant across sites.</li><li><code>θsMs</code>: ComponentArray <code>(n_site, n_θM, n_sample_pred)</code> of PBM model parameters that vary by site.</li><li><code>entropy_ζ</code>: The entropy of the log-determinant of the transformation of  the set of model parameters, which is involved in uncertainty quantification.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/elbo.jl#L198-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.sample_posterior-Tuple{Any, AbstractHybridProblem}" href="#HybridVariationalInference.sample_posterior-Tuple{Any, AbstractHybridProblem}"><code>HybridVariationalInference.sample_posterior</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_posterior(rng, prob, [xM::AbstractMatrix]; scenario=Val(()), kwargs...)</code></pre><p>Sampling the posterior parameter distribution  for hybrid variational inference problem. </p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: random number generator</li><li><code>prob</code>: The AbstractHybridProblem from to sample</li><li><code>xM</code>: covariates for the machine-learning model (ML): Matrix <code>(n_θM x n_site_pred)</code>. Default to all sites in <code>get_hybridproblem_train_dataloader(prob; scenario)</code>.</li></ul><p>Optional keyword arguments    </p><ul><li><code>scenario</code>: scenario to query <code>prob</code> and set default of gpu devices.</li><li><code>n_sample_pred</code>: number of samples to draw, defaults to 200</li><li><code>gdevs</code>: <code>NamedTuple(gdev_M, gdev_P)</code>: GPU devices for machine learning model  and parameter transformtation, default to <a href="#HybridVariationalInference.get_gdev_MP-Union{Tuple{Val{scen}}, Tuple{scen}} where scen"><code>get_gdev_MP</code></a><code>(scenario)</code>.</li><li><code>is_inferred</code>: set to <code>Val(true)</code> to activate type stabilicy check for transformation</li></ul><p>Returns an NamedTuple <code>(; θsP, θsMs, entropy_ζ)</code> with entries</p><ul><li><code>θsP</code>: ComponentArray <code>(n_θP, n_sample_pred)</code> of PBM model parameters that are kept constant across sites.</li><li><code>θsMs</code>: ComponentArray <code>(n_site, n_θM, n_sample_pred)</code> of PBM model parameters that vary by site.</li><li><code>entropy_ζ</code>: The entropy of the log-determinant of the transformation of  the set of model parameters, which is involved in uncertainty quantification.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/elbo.jl#L247-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.scale_centered_at" href="#HybridVariationalInference.scale_centered_at"><code>HybridVariationalInference.scale_centered_at</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale_centered_at(x, m, σrel=1.0)
scale_centered_at(x, m, σ)</code></pre><p>Centers and rescales rows of matrix <code>x</code> around vector <code>m</code>. The scale can either be given relative to <code>m</code> or specified as a vector of same size as <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/gencovar.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.select_ml_engine-Union{Tuple{}, Tuple{scen}} where scen" href="#HybridVariationalInference.select_ml_engine-Union{Tuple{}, Tuple{scen}} where scen"><code>HybridVariationalInference.select_ml_engine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_ml_engine(;scenario)</code></pre><p>Returns a value type <code>Val{:Symbol}</code> to dispatch on the machine learning engine to use.</p><ul><li>defaults to <code>Val(:SimpleChains)</code></li><li><code>:use_Lux ∈ scenario -&gt; Val(:Lux)</code></li><li><code>:use_Flux ∈ scenario -&gt; Val(:Flux)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ModelApplicator.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.stack_ca_int-Union{Tuple{n_dims}, Tuple{IT}, Tuple{IT, Val{n_dims}}} where {IT&lt;:AbstractComponentArrayInterpreter, n_dims}" href="#HybridVariationalInference.stack_ca_int-Union{Tuple{n_dims}, Tuple{IT}, Tuple{IT, Val{n_dims}}} where {IT&lt;:AbstractComponentArrayInterpreter, n_dims}"><code>HybridVariationalInference.stack_ca_int</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack_ca_int(cai::AbstractComponentArrayInterpreter, ::Val{n_dims})</code></pre><p>Interpret the first dimension of an Array as a ComponentArray. Provide the Tuple of following dimensions by a value type, e.g. <code>Val((n_col, n_z))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/ComponentArrayInterpreter.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.zero_penalty_loss-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Any, AbstractVector}" href="#HybridVariationalInference.zero_penalty_loss-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector, Any, AbstractVector}"><code>HybridVariationalInference.zero_penalty_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_penalty_loss(y_pred, θMs, θP, ϕg, ϕunc)</code></pre><p>Add zero i.e. no additional loss terms during the HVI fit.</p><p>The basic cost in HVI is the negative log of the joint probability, i.e. the likelihood of the observations given the parameters * prior probability of the parameters.</p><p>Sometimes there is additional knowledge not encoded in the prior, such as one parameter must be larger than another, or entropy-weights of the ML-parameters, and the solver accept a function to add additional loss terms.</p><p>Arguments</p><ul><li>y_pred::AbstractMatrix: Observations</li><li>θMs::AbstractMatrix: site parameters</li><li>θP::AbstractVector: global parameters</li><li>ϕg: ML-model parameters, </li><li>ϕunc::AbstractVector, additional parameters of the posterior</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/elbo.jl#L170-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.DoubleMM.f_doubleMM-Union{Tuple{ET}, Tuple{ComponentArrays.ComponentVector{ET}, Any}} where ET" href="#HybridVariationalInference.DoubleMM.f_doubleMM-Union{Tuple{ET}, Tuple{ComponentArrays.ComponentVector{ET}, Any}} where ET"><code>HybridVariationalInference.DoubleMM.f_doubleMM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f_doubleMM(θc::CA.ComponentVector{ET}, x) where ET</code></pre><p>Example process based model (PBM) predicts a double-monod constrained rate for different substrate concentration vectors, <code>x.S1</code>, and <code>x.S2</code> for a single site. θc is a ComponentVector with scalar parameters as components: <code>r0</code>, <code>r1</code>, <code>K1</code>, and <code>K2</code></p><p>It predicts a rate for each entry in concentrations: <code>y = r0 .+ r1 .* x.S1 ./ (K1 .+ x.S1) .* x.S2 ./ (K2 .+ x.S2)</code>.</p><p>It is defined as </p><pre><code class="language-julia hljs">function f_doubleMM(θc::ComponentVector{ET}, x) where ET
    # extract parameters not depending on order, i.e whether they are in θP or θM
    # r0 = θc[:r0]
    (r0, r1, K1, K2) = map((:r0, :r1, :K1, :K2)) do par
        getdata(θc[par])::ET
    end
    y = r0 .+ r1 .* x.S1 ./ (K1 .+ x.S1) .* x.S2 ./ (K2 .+ x.S2)
    return (y)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/DoubleMM/f_doubleMM.jl#L24-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HybridVariationalInference.DoubleMM.f_doubleMM_sites-Tuple{ComponentArrays.ComponentMatrix, ComponentArrays.ComponentMatrix}" href="#HybridVariationalInference.DoubleMM.f_doubleMM_sites-Tuple{ComponentArrays.ComponentMatrix, ComponentArrays.ComponentMatrix}"><code>HybridVariationalInference.DoubleMM.f_doubleMM_sites</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">f_doubleMM_sites(θc::CA.ComponentMatrix, xPc::CA.ComponentMatrix)</code></pre><p>Example process based model (PBM) that predicts for a batch of sites.</p><p>Arguments</p><ul><li><code>θc</code>: parameters with one row per site and symbolic column index </li><li><code>xPc</code>: model drivers with one column per site, and symbolic row index</li></ul><p>Returns a matrix <code>(n_obs x n_site)</code> of predictions.</p><pre><code class="language-julia hljs">function f_doubleMM_sites(θc::ComponentMatrix, xPc::ComponentMatrix)
    # extract several covariates from xP
    ST = typeof(CA.getdata(xPc)[1:1,:])  # workaround for non-type-stable Symbol-indexing
    S1 = (CA.getdata(xPc[:S1,:])::ST)   
    S2 = (CA.getdata(xPc[:S2,:])::ST)
    #
    # extract the parameters as vectors that are row-repeated into a matrix
    VT = typeof(CA.getdata(θc)[:,1])   # workaround for non-type-stable Symbol-indexing
    n_obs = size(S1, 1)
    rep_fac = ones_similar_x(xPc, n_obs)      # to reshape into matrix, avoiding repeat
    (r0, r1, K1, K2) = map((:r0, :r1, :K1, :K2)) do par
        p1 = CA.getdata(θc[:, par]) ::VT
        #(r0 .* rep_fac)&#39;    # move to computation below to save allocation
        #repeat(p1&#39;, n_obs)  # matrix: same for each concentration row in S1
    end
    #
    # each variable is a matrix (n_obs x n_site)
    #r0 .+ r1 .* S1 ./ (K1 .+ S1) .* S2 ./ (K2 .+ S2)
    (r0 .* rep_fac)&#39; .+ (r1 .* rep_fac)&#39; .* S1 ./ ((K1 .* rep_fac)&#39; .+ S1) .* S2 ./ ((K2 .* rep_fac)&#39; .+ S2)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EarthyScience/HybridVariationalInference.jl/blob/900b5f3c6a9d2d644975567bd744f8af7fd461ca/src/DoubleMM/f_doubleMM.jl#L66-L99">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/corr_site_global/">« .. model site-global corr</a><a class="docs-footer-nextpage" href="../reference_internal/">Internal »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 23 August 2025 16:17">Saturday 23 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
