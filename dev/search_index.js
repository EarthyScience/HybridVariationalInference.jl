var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = HybridVariationalInference","category":"page"},{"location":"#HybridVariationalInference","page":"Home","title":"HybridVariationalInference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HybridVariationalInference.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [HybridVariationalInference]","category":"page"},{"location":"#HybridVariationalInference.AbstractComponentArrayInterpreter","page":"Home","title":"HybridVariationalInference.AbstractComponentArrayInterpreter","text":"AbstractComponentArrayInterpreter\n\nInterface for Type that implements\n\nas_ca(::AbstractArray, interpreter) -> ComponentArray\nBase.length(interpreter) -> Int\n\nWhen called on a vector, forwards to as_ca.\n\n\n\n\n\n","category":"type"},{"location":"#HybridVariationalInference.AbstractHybridCase","page":"Home","title":"HybridVariationalInference.AbstractHybridCase","text":"Type to dispatch constructing data and network structures for different cases of hybrid problem setups\n\nFor a specific case, provide functions that specify details\n\ngethybridcasepar_templates\ngethybridcasesizes\ngenhybridcaseMLapplicator\ngenhybridcasePBmodel\n\noptionally\n\ngenhybridcasesynthetic\ngethybridcaseFloatType (if it should differ from Float32)\n\n\n\n\n\n","category":"type"},{"location":"#HybridVariationalInference.ComponentArrayInterpreter","page":"Home","title":"HybridVariationalInference.ComponentArrayInterpreter","text":"Non-Concrete version of AbstractComponentArrayInterpreter that avoids storing additional type parameters.\n\nDoes not trigger specialization for Interpreters of different axes, but does not allow compiler-inferred length to construct StaticArrays.\n\nUse get_concrete(cai::ComponentArrayInterpreter) to pass a concrete version to  performance-critical functions.\n\n\n\n\n\n","category":"type"},{"location":"#HybridVariationalInference.ComponentArrayInterpreter-Tuple{NamedTuple}","page":"Home","title":"HybridVariationalInference.ComponentArrayInterpreter","text":"ComponentArrayInterpreter(; kwargs...)\nComponentArrayInterpreter(::AbstractComponentArray)\nComponentArrayInterpreter(::AbstractComponentArray, n_dims::NTuple{N,<:Integer})\nComponentArrayInterpreter(n_dims::NTuple{N,<:Integer}, ::AbstractComponentArray)\n\nConstruct a ComponentArrayInterpreter <: AbstractComponentArrayInterpreter with components being vectors of given length or given model of a AbstractComponentArray.\n\nThe other constructors allow constructing arrays with additional dimensions.\n\n'''julia     interpreter = ComponentArrayInterpreter(; P=2, M=(2,3), Unc=5)     v = 1.0:length(interpreter)     interpreter(v).M == 2 .+ [1 3 5; 2 4 6]     vm = stack((v,v .* 10, v .* 100))\n\nintm = ComponentArrayInterpreter(interpreter(v), (3,))\nintm(vm)[:Unc, 2]\n\n'''\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.ComponentArrayInterpreter-Tuple{}","page":"Home","title":"HybridVariationalInference.ComponentArrayInterpreter","text":"ComponentArrayInterpreter(; kwargs...)\nComponentArrayInterpreter(::AbstractComponentArray)\nComponentArrayInterpreter(::AbstractComponentArray, n_dims::NTuple{N,<:Integer})\nComponentArrayInterpreter(n_dims::NTuple{N,<:Integer}, ::AbstractComponentArray)\n\nConstruct a ComponentArrayInterpreter <: AbstractComponentArrayInterpreter with components being vectors of given length or given model of a AbstractComponentArray.\n\nThe other constructors allow constructing arrays with additional dimensions.\n\n'''julia     interpreter = ComponentArrayInterpreter(; P=2, M=(2,3), Unc=5)     v = 1.0:length(interpreter)     interpreter(v).M == 2 .+ [1 3 5; 2 4 6]     vm = stack((v,v .* 10, v .* 100))\n\nintm = ComponentArrayInterpreter(interpreter(v), (3,))\nintm(vm)[:Unc, 2]\n\n'''\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.StaticComponentArrayInterpreter","page":"Home","title":"HybridVariationalInference.StaticComponentArrayInterpreter","text":"Concrete version of AbstractComponentArrayInterpreter that stores an axis in its type signature.\n\nAllows compiler-inferred length to construct StaticArrays, but requires specialization on dispatch when provided as an argument to a function.\n\nUse get_concrete(cai::ComponentArrayInterpreter) to pass a concrete version to  performance-critical functions.\n\n\n\n\n\n","category":"type"},{"location":"#HybridVariationalInference.as_ca","page":"Home","title":"HybridVariationalInference.as_ca","text":"as_ca(v::AbstractArray, interpretor)\n\nReturns a ComponentArray with underlying data v.\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.callback_loss","page":"Home","title":"HybridVariationalInference.callback_loss","text":"create a function (state, l) -> false that prints iter and loss each moditer\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.compute_correlated_covars-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T}}} where T","page":"Home","title":"HybridVariationalInference.compute_correlated_covars","text":"Create n_covar correlated covariates  from uncorrelated row-wise vector x_pc, with correlations rhos to the linear combinations of x_pc.\n\nBy default correlations, rhos = (1.0),0.88,0.78,0.69,0.61 ...,  decrease exponentially as e^{-i/rhodec}, with rhodec = 8.\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.flatten1-Tuple{ComponentArrays.ComponentVector}","page":"Home","title":"HybridVariationalInference.flatten1","text":"Removes the highest level of keys. Keeps the reference to the underlying data, but changes the axis. If first-level vector has no sub-names, an error (Aguement Error tuple must be non-empty) is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.gen_cov_pred-Tuple{Random.AbstractRNG, DataType, Any, Any, Any, Integer}","page":"Home","title":"HybridVariationalInference.gen_cov_pred","text":"Generate correlated covariates and synthetic true parameters that are a linear combination of the uncorrelated underlying principal  factors and their binary combinations.\n\nIn addition provide a SimpleChains model of adequate complexity to fit this relationship θMstrue = f(xo)\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.gen_hybridcase_MLapplicator","page":"Home","title":"HybridVariationalInference.gen_hybridcase_MLapplicator","text":"gen_hybridcase_MLapplicator(::AbstractHybridCase, MLEngine, n_covar, n_out; scenario=())\n\nConstruct the machine learning model fro given problem case and ML-Framework and  scenario.\n\nThe MLEngine is a value type of a Symbol, usually the name of the module, e.g.  const MLengine = Val(nameof(SimpleChains)).\n\nreturns a Tuple of\n\nAbstractModelApplicator\ninitial parameter vector\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.gen_hybridcase_PBmodel","page":"Home","title":"HybridVariationalInference.gen_hybridcase_PBmodel","text":"gen_hybridcase_PBmodel(::AbstractHybridCase; scenario::NTuple=())\n\nConstruct the process-based model function  f(θP::AbstractVector, θMs::AbstractMatrix, x) -> (AbstractVector, AbstractMatrix) with\n\nθP: calibrated parameters that are constant across site\nθMs: calibrated parameters that vary across sites, with a  column for each site\nx: drivers, indexed by site\n\nreturns a tuple of predictions with components\n\nfirst, those that are constant across sites\nsecond, those that vary across sites, with a column for each site\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.gen_hybridcase_synthetic","page":"Home","title":"HybridVariationalInference.gen_hybridcase_synthetic","text":"gen_hybridcase_synthetic(::AbstractHybridCase, rng; scenario)\n\nSetup synthetic data, a NamedTuple of\n\nxM: matrix of covariates, with one column per site\nθP_true: vector global process-model parameters\nθMs_true: matrix of site-varying process-model parameters, with \nxP: Vector of process-model drivers, with an entry per site\nyglobaltrue: vector of global observations\ny_true: matrix of site-specific observations with one column per site\nyglobalo, y_o: observations with added noise\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.get_hybridcase_FloatType-Tuple{AbstractHybridCase}","page":"Home","title":"HybridVariationalInference.get_hybridcase_FloatType","text":"get_hybridcase_FloatType(::AbstractHybridCase; scenario)\n\nDetermine the FloatType for given Case and scenario, defaults to Float32\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.get_hybridcase_par_templates","page":"Home","title":"HybridVariationalInference.get_hybridcase_par_templates","text":"get_hybridcase_par_templates(::AbstractHybridCase; scenario)\n\nProvide tuple of templates of ComponentVectors θP and θM.\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.get_hybridcase_sizes","page":"Home","title":"HybridVariationalInference.get_hybridcase_sizes","text":"get_hybridcase_par_templates(::AbstractHybridCase; scenario)\n\nProvide a NamedTuple of number of \n\nn_covar: covariates xM\nn_site: all sites in the data\nn_batch: sites in one minibatch during fitting\nnθM, nθP: entries in parameter vectors\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.get_loss_gf-Tuple{Any, Any, Any, HybridVariationalInference.AbstractComponentArrayInterpreter}","page":"Home","title":"HybridVariationalInference.get_loss_gf","text":"Create a loss function for parameter vector p, given \n\ng(x, ϕ): machine learning model \nf(θMs, θP): mechanistic model \nx_o: matrix of covariates, sites in columns\ny_o: matrix of observations, sites in columns\nint_ϕθP: interpreter attachin axis with compponents ϕg and pc.θP\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.gf-NTuple{6, Any}","page":"Home","title":"HybridVariationalInference.gf","text":"composition f ∘ g: mechanistic model after machine learning parameter prediction\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.invsumn-Tuple{T} where T","page":"Home","title":"HybridVariationalInference.invsumn","text":"Inverse of s = sumn(n) for positive integer n.\n\nGives an inexact error, if given s was not such a sum.\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.scale_centered_at","page":"Home","title":"HybridVariationalInference.scale_centered_at","text":"scale_centered_at(x, m, σrel=1.0)\nscale_centered_at(x, m, σ)\n\nCenters and rescales rows of matrix x around vector m. The scale can either be given relative to m or specified as a vector of same size as m.\n\n\n\n\n\n","category":"function"},{"location":"#HybridVariationalInference.transformU_cholesky1-Tuple{AbstractVector}","page":"Home","title":"HybridVariationalInference.transformU_cholesky1","text":"Takes a vector of entries of a lower UnitUpperTriangular matrix and transforms it to an UpperTriangular that satisfies  diag(U' * U) = 1.\n\nThis can be used to fit parameters that yield an upper Cholesky-Factor of a Covariance matrix.\n\nIt uses the upper triangular matrix rather than the lower because it involes a sum across columns, whereas the alternative of a lower triangular uses sum across rows.  Sum across columns is often faster, because entries of columns are contiguous.\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.utri2vec-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"HybridVariationalInference.utri2vec","text":"Extract entries of upper diagonal matrix of UppterTriangular to columnwise vector\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.utri2vec_pos-Tuple{Any, Any}","page":"Home","title":"HybridVariationalInference.utri2vec_pos","text":"Compute the index in the vector of entries in an upper tridiagonal matrix\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.uutri2vec-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Home","title":"HybridVariationalInference.uutri2vec","text":"Extract entries of upper diagonal matrix of UnitUppterTriangular to columnwise vector\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.vec2utri-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Home","title":"HybridVariationalInference.vec2utri","text":"Convert vector v columnwise entries of upper diagonal matrix to UppterTriangular\n\n\n\n\n\n","category":"method"},{"location":"#HybridVariationalInference.vec2utri_pos-Tuple{Any, Any}","page":"Home","title":"HybridVariationalInference.vec2utri_pos","text":"Compute the (one-based) position (row, col) within an upper tridiagonal matrix for given (one-based) position, s within a packed vector representation.\n\n\n\n\n\n","category":"method"}]
}
